#!/usr/bin/env python
from __future__ import print_function, division
from optparse import OptionParser
import os
import sys
import numpy as np

__author__ = "Louis Dijkstra"

usage = """%prog [options] <calls-file> 

	<calls-file>	output file generated by sm_call 

Test; used for estimating alpha. 
"""

def makeCall (p_somatic, p_germline, p_not_present):
	"""Makes the call on the basis of the posterior probabilities."""
	if p_somatic > p_germline and p_somatic > p_not_present:
		return 'SOMATIC', p_somatic
	if p_germline > p_somatic and p_germline > p_not_present:
		return 'GERMLINE', p_germline
	return 'ABSENT', p_not_present	


def upperboundEstimate (h_vaf, c_vaf):
	if h_vaf == 0.0: 
		return 1.0 - c_vaf 
	elif h_vaf == 0.5:
		return 2 * min(c_vaf, 1.0 - c_vaf) 
	elif h_vaf == 1.0:
		return c_vaf 

def main():

	parser = OptionParser(usage=usage)
	(options, args) = parser.parse_args()
	
	if (len(args)!=1):
		parser.print_help()
		return 1
	
	calls_filename 		= os.path.abspath(args[0])
	calls_file		= open(calls_filename, 'r') ; 

	upper_bounds = [] 
	mean = 0.0 

	for line in calls_file: 
		values 	= line.split('\t')
		# extract data
		variant_type 	= values[0]
		autosome 	= int(values[1])
		position 	= int(values[2])
		length 		= int(values[3])
		
		call = 'UNKNOWN'
		post_prob_call = 'NONE'
		h_vaf, c_vaf, max_logl = 'NONE', 'NONE', 'NONE' 
		p_somatic, p_germline, p_not_present = 'NONE', 'NONE', 'NONE'
	
		if values[4].strip() != '.':	h_vaf 		= float(values[4])
		if values[5].strip() != '.': 	c_vaf 		= float(values[5])
		if values[6].strip() != '.':	max_logl	= float(values[6])
		if values[7].strip() != '.':	p_somatic 	= float(values[7])
		if values[8].strip() != '.':	p_germline 	= float(values[8])
		if values[9].strip() != '.':	p_not_present 	= float(values[9])
		
		if not (p_somatic is 'NONE' and p_germline is 'NONE' and p_not_present is 'NONE'):
			# make call
			call, post_prob_call = makeCall(p_somatic, p_germline, p_not_present)
			if (h_vaf != 0.0 and c_vaf != 0.0) : 
				upper_bounds.append(upperboundEstimate(h_vaf, c_vaf))
				print(h_vaf, c_vaf, upperboundEstimate(h_vaf, c_vaf))
				mean += upperboundEstimate(h_vaf, c_vaf)

	n_bins = 100 
	for a in range(0, n_bins + 1):
		alpha = float(a) / float(n_bins)
		n = 0 
		for u in upper_bounds:
			if u <= alpha:
				n += 1 
		print(alpha, n) 
	
		
	
			
			 

if __name__ == '__main__':
	sys.exit(main())
